using System.Linq;
using System.Text;

namespace ZenohDotNet.Generator;

/// <summary>
/// Generates serialization methods for Zenoh message types.
/// </summary>
internal static class SerializerGenerator
{
    public static string Generate(ZenohMessageTypeInfo typeInfo)
    {
        var sb = new StringBuilder();
        
        // Determine the type keyword
        string typeKind;
        if (typeInfo.IsRecord)
        {
            typeKind = typeInfo.TypeKind == Microsoft.CodeAnalysis.TypeKind.Struct ? "record struct" : "record";
        }
        else
        {
            typeKind = typeInfo.TypeKind == Microsoft.CodeAnalysis.TypeKind.Struct ? "struct" : "class";
        }

        sb.AppendLine("// <auto-generated/>");
        sb.AppendLine("#nullable enable");
        sb.AppendLine();
        sb.AppendLine("using System;");
        sb.AppendLine("using System.Buffers;");
        sb.AppendLine("using System.Text;");
        sb.AppendLine("using System.Text.Json;");
        sb.AppendLine("using ZenohDotNet.Generated;");
        sb.AppendLine();

        if (!string.IsNullOrEmpty(typeInfo.Namespace))
        {
            sb.AppendLine($"namespace {typeInfo.Namespace};");
            sb.AppendLine();
        }

        sb.AppendLine($"partial {typeKind} {typeInfo.TypeName} : IZenohGeneratedMessage");
        sb.AppendLine("{");

        // Generate static serialization methods
        GenerateSerializeMethods(sb, typeInfo);
        GenerateDeserializeMethods(sb, typeInfo);
        GenerateHelperMethods(sb, typeInfo);

        sb.AppendLine("}");

        return sb.ToString();
    }

    private static void GenerateSerializeMethods(StringBuilder sb, ZenohMessageTypeInfo typeInfo)
    {
        var typeName = typeInfo.TypeName;
        var isStruct = typeInfo.TypeKind == Microsoft.CodeAnalysis.TypeKind.Struct;
        var inModifier = isStruct ? "in " : "";

        sb.AppendLine("    /// <summary>");
        sb.AppendLine("    /// Serializes this message to a byte array.");
        sb.AppendLine("    /// </summary>");
        sb.AppendLine("    public byte[] ToBytes()");
        sb.AppendLine("    {");

        switch (typeInfo.Encoding)
        {
            case ZenohEncodingKind.Json:
                sb.AppendLine("        return JsonSerializer.SerializeToUtf8Bytes(this);");
                break;
            case ZenohEncodingKind.MessagePack:
                sb.AppendLine("        return MessagePack.MessagePackSerializer.Serialize(this);");
                break;
            case ZenohEncodingKind.Custom:
                sb.AppendLine("        throw new NotImplementedException(\"Custom serialization requires IZenohSerializer implementation.\");");
                break;
        }

        sb.AppendLine("    }");
        sb.AppendLine();

        // Static serialize with in parameter for structs
        sb.AppendLine("    /// <summary>");
        sb.AppendLine("    /// Serializes the message to a byte array (static version).");
        sb.AppendLine("    /// </summary>");
        sb.AppendLine($"    public static byte[] Serialize({inModifier}{typeName} value)");
        sb.AppendLine("    {");

        switch (typeInfo.Encoding)
        {
            case ZenohEncodingKind.Json:
                sb.AppendLine("        return JsonSerializer.SerializeToUtf8Bytes(value);");
                break;
            case ZenohEncodingKind.MessagePack:
                sb.AppendLine("        return MessagePack.MessagePackSerializer.Serialize(value);");
                break;
            case ZenohEncodingKind.Custom:
                sb.AppendLine("        throw new NotImplementedException(\"Custom serialization requires IZenohSerializer implementation.\");");
                break;
        }

        sb.AppendLine("    }");
        sb.AppendLine();

        // Serialize to Span<byte> for zero-allocation (returns bytes written)
        sb.AppendLine("    /// <summary>");
        sb.AppendLine("    /// Serializes the message to a span, returning the number of bytes written.");
        sb.AppendLine("    /// </summary>");
        sb.AppendLine($"    public static int SerializeTo({inModifier}{typeName} value, Span<byte> destination)");
        sb.AppendLine("    {");

        switch (typeInfo.Encoding)
        {
            case ZenohEncodingKind.Json:
                sb.AppendLine("        var bufferWriter = new ArrayBufferWriter<byte>(destination.Length);");
                sb.AppendLine("        using var writer = new Utf8JsonWriter(bufferWriter);");
                sb.AppendLine("        JsonSerializer.Serialize(writer, value);");
                sb.AppendLine("        var written = bufferWriter.WrittenSpan;");
                sb.AppendLine("        written.CopyTo(destination);");
                sb.AppendLine("        return written.Length;");
                break;
            case ZenohEncodingKind.MessagePack:
                sb.AppendLine("        var bytes = MessagePack.MessagePackSerializer.Serialize(value);");
                sb.AppendLine("        bytes.AsSpan().CopyTo(destination);");
                sb.AppendLine("        return bytes.Length;");
                break;
            case ZenohEncodingKind.Custom:
                sb.AppendLine("        throw new NotImplementedException(\"Custom serialization requires IZenohSerializer implementation.\");");
                break;
        }

        sb.AppendLine("    }");
        sb.AppendLine();
    }

    private static void GenerateDeserializeMethods(StringBuilder sb, ZenohMessageTypeInfo typeInfo)
    {
        var typeName = typeInfo.TypeName;
        var isStruct = typeInfo.TypeKind == Microsoft.CodeAnalysis.TypeKind.Struct;

        // Deserialize from byte[]
        sb.AppendLine("    /// <summary>");
        sb.AppendLine("    /// Deserializes a message from a byte array.");
        sb.AppendLine("    /// </summary>");
        sb.AppendLine($"    public static {typeName} Deserialize(byte[] data)");
        sb.AppendLine("    {");

        switch (typeInfo.Encoding)
        {
            case ZenohEncodingKind.Json:
                if (isStruct)
                {
                    sb.AppendLine($"        return JsonSerializer.Deserialize<{typeName}>(data);");
                }
                else
                {
                    sb.AppendLine($"        return JsonSerializer.Deserialize<{typeName}>(data) ?? throw new JsonException(\"Failed to deserialize {typeName}\");");
                }
                break;
            case ZenohEncodingKind.MessagePack:
                sb.AppendLine($"        return MessagePack.MessagePackSerializer.Deserialize<{typeName}>(data);");
                break;
            case ZenohEncodingKind.Custom:
                sb.AppendLine("        throw new NotImplementedException(\"Custom deserialization requires IZenohSerializer implementation.\");");
                break;
        }

        sb.AppendLine("    }");
        sb.AppendLine();

        // Deserialize from ReadOnlySpan<byte>
        sb.AppendLine("    /// <summary>");
        sb.AppendLine("    /// Deserializes a message from a span.");
        sb.AppendLine("    /// </summary>");
        sb.AppendLine($"    public static {typeName} Deserialize(ReadOnlySpan<byte> data)");
        sb.AppendLine("    {");

        switch (typeInfo.Encoding)
        {
            case ZenohEncodingKind.Json:
                if (isStruct)
                {
                    sb.AppendLine($"        return JsonSerializer.Deserialize<{typeName}>(data);");
                }
                else
                {
                    sb.AppendLine($"        return JsonSerializer.Deserialize<{typeName}>(data) ?? throw new JsonException(\"Failed to deserialize {typeName}\");");
                }
                break;
            case ZenohEncodingKind.MessagePack:
                sb.AppendLine($"        return MessagePack.MessagePackSerializer.Deserialize<{typeName}>(new ReadOnlySequence<byte>(data.ToArray()));");
                break;
            case ZenohEncodingKind.Custom:
                sb.AppendLine("        throw new NotImplementedException(\"Custom deserialization requires IZenohSerializer implementation.\");");
                break;
        }

        sb.AppendLine("    }");
        sb.AppendLine();

        // TryDeserialize
        sb.AppendLine("    /// <summary>");
        sb.AppendLine("    /// Attempts to deserialize a message, returning false on failure.");
        sb.AppendLine("    /// </summary>");
        sb.AppendLine($"    public static bool TryDeserialize(ReadOnlySpan<byte> data, out {typeName} result)");
        sb.AppendLine("    {");
        sb.AppendLine("        try");
        sb.AppendLine("        {");
        sb.AppendLine("            result = Deserialize(data);");
        sb.AppendLine("            return true;");
        sb.AppendLine("        }");
        sb.AppendLine("        catch");
        sb.AppendLine("        {");

        if (typeInfo.TypeKind == Microsoft.CodeAnalysis.TypeKind.Struct)
        {
            sb.AppendLine("            result = default;");
        }
        else
        {
            sb.AppendLine("            result = default!;");
        }

        sb.AppendLine("            return false;");
        sb.AppendLine("        }");
        sb.AppendLine("    }");
        sb.AppendLine();
    }

    private static void GenerateHelperMethods(StringBuilder sb, ZenohMessageTypeInfo typeInfo)
    {
        var keyParameters = typeInfo.Properties.Where(p => p.IsKeyParameter).ToList();
        var hasKeyParameters = keyParameters.Any() && !string.IsNullOrEmpty(typeInfo.DefaultKey);

        // Default key accessor (template with placeholders)
        if (!string.IsNullOrEmpty(typeInfo.DefaultKey))
        {
            sb.AppendLine("    /// <summary>");
            sb.AppendLine("    /// Gets the default key expression template for this message type.");
            if (hasKeyParameters)
            {
                sb.AppendLine("    /// Contains placeholders that are replaced by BuildKeyExpression().");
            }
            sb.AppendLine("    /// </summary>");
            sb.AppendLine($"    public static string DefaultKeyExpression => \"{typeInfo.DefaultKey}\";");
            sb.AppendLine();
        }

        // BuildKeyExpression method (instance)
        if (hasKeyParameters)
        {
            sb.AppendLine("    /// <summary>");
            sb.AppendLine("    /// Builds the key expression by replacing placeholders with property values.");
            sb.AppendLine("    /// </summary>");
            sb.AppendLine("    public string BuildKeyExpression()");
            sb.AppendLine("    {");
            sb.AppendLine($"        var key = \"{typeInfo.DefaultKey}\";");
            foreach (var param in keyParameters)
            {
                var placeholder = param.KeyParameterName ?? param.Name;
                sb.AppendLine($"        key = key.Replace(\"{{{placeholder}}}\", {param.Name}?.ToString() ?? string.Empty);");
            }
            sb.AppendLine("        return key;");
            sb.AppendLine("    }");
            sb.AppendLine();

            // Static BuildKeyExpression with parameters
            sb.AppendLine("    /// <summary>");
            sb.AppendLine("    /// Builds the key expression from the specified parameter values.");
            sb.AppendLine("    /// </summary>");
            var paramList = string.Join(", ", keyParameters.Select(p => $"{p.TypeName} {ToCamelCase(p.Name)}"));
            sb.AppendLine($"    public static string BuildKeyExpression({paramList})");
            sb.AppendLine("    {");
            sb.AppendLine($"        var key = \"{typeInfo.DefaultKey}\";");
            foreach (var param in keyParameters)
            {
                var placeholder = param.KeyParameterName ?? param.Name;
                sb.AppendLine($"        key = key.Replace(\"{{{placeholder}}}\", {ToCamelCase(param.Name)}?.ToString() ?? string.Empty);");
            }
            sb.AppendLine("        return key;");
            sb.AppendLine("    }");
            sb.AppendLine();
        }

        // Subscription patterns
        if (!typeInfo.SubscriptionPatterns.IsDefaultOrEmpty)
        {
            for (int i = 0; i < typeInfo.SubscriptionPatterns.Length; i++)
            {
                var pattern = typeInfo.SubscriptionPatterns[i];
                var suffix = typeInfo.SubscriptionPatterns.Length > 1 ? (i + 1).ToString() : "";
                sb.AppendLine("    /// <summary>");
                sb.AppendLine($"    /// Gets the subscription pattern for subscribing to messages of this type.");
                sb.AppendLine("    /// </summary>");
                sb.AppendLine($"    public static string SubscriptionPattern{suffix} => \"{pattern}\";");
                sb.AppendLine();
            }
        }

        // Encoding info
        sb.AppendLine("    /// <summary>");
        sb.AppendLine("    /// Gets the encoding format used for this message type.");
        sb.AppendLine("    /// </summary>");
        sb.AppendLine($"    public static ZenohDotNet.Abstractions.ZenohEncoding MessageEncoding => ZenohDotNet.Abstractions.ZenohEncoding.{typeInfo.Encoding};");
    }

    private static string ToCamelCase(string name)
    {
        if (string.IsNullOrEmpty(name)) return name;
        return char.ToLowerInvariant(name[0]) + name.Substring(1);
    }
}
